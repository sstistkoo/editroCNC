<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>CNC Editor - Sinumerik 840D</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .simulator {
            height: 50vh;
            width: 100%;
            border-bottom: 1px solid #ccc;
        }

        .editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #fff;
            position: relative;
            overflow: hidden;
            min-height: 0; /* D≈Øle≈æit√© pro spr√°vn√© scrollov√°n√≠ */
        }

        .canvas-container {
            width: 100%;
            height: 100%;
            background: #f8f9fa;
        }

        .axis-label {
            position: absolute;
            color: #000;
            font-weight: bold;
        }

        .axis-label.x {
            bottom: 10px;
            right: 10px;
        }

        .axis-label.z {
            top: 10px;
            left: 10px;
        }

        .position-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 24px; /* Zvƒõt≈°eno z 14px */
            font-family: monospace;
            z-index: 1000;
            pointer-events: none;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
            min-width: 220px; /* P≈ôid√°no pro lep≈°√≠ ƒçitelnost */
        }

        /* Mobiln√≠ optimalizace */
        @media (max-width: 768px) {
            .simulator {
                height: 45vh; /* Zvƒõt≈°en prostor pro simul√°tor */
            }

            .editor-container {
                height: 45vh; /* Upraveno pro lep≈°√≠ zobrazen√≠ */
            }

            .toolbar {
                padding: 5px;
                gap: 5px;
            }

            .toolbar button {
                height: 40px;
                min-width: 100px;
                font-size: 16px;
                margin: 2px;
                border-radius: 4px;
                border: 1px solid #ccc;
                background: white;
                touch-action: manipulation;
            }

            .toolbar button:active {
                background: #e6e6e6;
            }

            .position-info {
                font-size: 20px; /* Zvƒõt≈°eno pro mobily */
                padding: 12px 16px;
                right: 5px;
                top: 5px;
                background: rgba(0, 0, 0, 0.9);
            }

            #editor {
                font-size: 16px; /* Vƒõt≈°√≠ p√≠smo pro mobiln√≠ za≈ô√≠zen√≠ */
                line-height: 1.4;
                padding: 8px;
                -webkit-tap-highlight-color: rgba(0,0,0,0);
            }

            /* Vylep≈°en√≠ scrollov√°n√≠ pro touch za≈ô√≠zen√≠ */
            .editor-container::-webkit-scrollbar {
                width: 8px;
            }

            .editor-container::-webkit-scrollbar-thumb {
                background: rgba(0,0,0,0.2);
                border-radius: 4px;
            }
        }

        /* Vylep≈°en√≠ pro dotykov√© ovl√°d√°n√≠ */
        @media (hover: none) {
            .toolbar button {
                padding: 12px; /* Vƒõt≈°√≠ tlaƒç√≠tka pro dotyk */
                margin: 2px;
            }

            #editor {
                -webkit-overflow-scrolling: touch;
            }

            .tooltip {
                padding: 10px 20px;
                font-size: 18px;
            }

            .crosshair {
                width: 30px;
                height: 30px;
            }

            .crosshair::before {
                left: 14px;
                width: 2px;
                height: 30px;
            }

            .crosshair::after {
                top: 14px;
                height: 2px;
                width: 30px;
            }

            /* Zvƒõt≈°en√≠ dotykov√© plochy pro body */
            .canvas-container canvas {
                touch-action: none; /* Zabr√°nit v√Ωchoz√≠m gest≈Øm */
            }
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px; /* Zvƒõt≈°it vnit≈ôn√≠ odsazen√≠ */
            border-radius: 6px;
            font-size: 16px; /* Zvƒõt≈°it p√≠smo */
            pointer-events: none;
            z-index: 1000;
            min-width: 120px; /* P≈ôidat minim√°ln√≠ ≈°√≠≈ôku */
            text-align: center; /* Vycentrovat text */
        }

        .crosshair {
            position: absolute;
            width: 20px;
            height: 20px;
            pointer-events: none;
            display: none;
            z-index: 1001;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: #000;
        }

        .crosshair::before {
            left: 9px;
            width: 2px;
            height: 20px;
        }

        .crosshair::after {
            top: 9px;
            height: 2px;
            width: 20px;
        }

        #editor {
            width: 100%;
            height: 100%; /* Zmƒõnƒõno - editor vypln√≠ cel√Ω prostor */
            resize: none; /* Zak√°z√°n√≠ manu√°ln√≠ho resizu */
            padding: 10px;
            box-sizing: border-box;
            font-family: monospace;
            border: none;
            outline: none;
            background: #fff;
            line-height: 1.5;
            cursor: pointer;
            background: linear-gradient(
                transparent calc(1.5em * var(--selected-line)),
                #e6f3ff calc(1.5em * var(--selected-line)),
                #e6f3ff calc(1.5em * (var(--selected-line) + 1)),
                transparent calc(1.5em * (var(--selected-line) + 1))
            );
            background-size: 100% 100%;
            line-height: 1.5em;
            -webkit-overflow-scrolling: touch; /* P≈ôid√°no pro iOS smooth scroll */
            overflow-y: auto; /* P≈ôid√°no - povolit vertik√°ln√≠ scroll */
            position: absolute; /* P≈ôid√°no */
            top: 0; /* P≈ôid√°no */
            left: 0; /* P≈ôid√°no */
            right: 0; /* P≈ôid√°no */
            bottom: 0; /* P≈ôid√°no */
            -webkit-overflow-scrolling: touch;
            overflow-y: auto;
            overscroll-behavior: contain;
            touch-action: pan-y;
            user-select: text;
            -webkit-user-select: text;
            padding: 16px; /* Vƒõt≈°√≠ padding pro lep≈°√≠ dotykov√© ovl√°d√°n√≠ */
            font-size: 16px; /* Vƒõt≈°√≠ p√≠smo pro mobily */
        }

        /* P≈ôid√°no - styl pro zv√Ωraznƒõn√Ω ≈ô√°dek */
        #editor.has-selection {
            background: linear-gradient(
                transparent 0%,
                transparent calc(1.5em * var(--selected-line)),
                #e6f3ff calc(1.5em * var(--selected-line)),
                #e6f3ff calc(1.5em * (var(--selected-line) + 1)),
                transparent calc(1.5em * (var(--selected-line) + 1))
            );
        }

        .editor-line-highlight {
            background-color: #e6f3ff;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(2); opacity: 0.5; }
            100% { transform: scale(1); opacity: 1; }
        }

        .point-pulse {
            animation: pulse 1s infinite;
        }

        /* P≈ôid√°na nov√° animace pro pulzuj√≠c√≠ bod */
        @keyframes pointPulse {
            0% {
                stroke-opacity: 1;
                r: 5;
            }
            50% {
                stroke-opacity: 0.8;
                r: 10;
            }
            100% {
                stroke-opacity: 1;
                r: 5;
            }
        }

        /* P≈ôidat styly pro ovl√°dac√≠ prvky p≈ôehr√°vaƒçe */
        .player-controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 5px;
            border-radius: 4px;
            display: flex;
            gap: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .player-controls button {
            padding: 5px 10px;
            border: 1px solid #ccc;
            background: white;
            border-radius: 3px;
            cursor: pointer;
        }

        .player-controls button:hover {
            background: #f0f0f0;
        }

        .player-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .playback-progress {
            position: absolute;
            bottom: 50px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px;
            border-radius: 4px;
            font-size: 12px;
        }

        /* Upravit styly p≈ôehr√°vaƒçe */
        .player-controls {
            /* ...existing styles... */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .player-controls button {
            width: 40px;
            height: 40px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            /* ...rest of existing button styles... */
        }

        #speedSlider {
            width: 100px;
        }

        /* P≈ôidat nov√© styly pro p≈ôehr√°vaƒç nad editorem */
        .controls-container {
            padding: 10px;
            background: #f5f5f5;
            border-top: 1px solid #ddd;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .player-container {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
        }

        .player-controls {
            position: static;
            transform: none;
            background: none;
            box-shadow: none;
            padding: 0;
            display: flex;
            align-items: center;
            gap: 5px;
            margin: 0;
        }

        .player-controls button {
            width: 40px;
            height: 40px;
            padding: 0;
            border-radius: 20px;
            border: 1px solid #ccc;
            background: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }

        #speedSlider {
            width: 100px;
            margin: 0;
        }

        /* Mobiln√≠ optimalizace */
        @media (max-width: 768px) {
            .controls-container {
                flex-direction: column;
                padding: 5px;
            }

            .player-container {
                width: 100%;
                justify-content: center;
            }

            .player-controls button {
                width: 50px;
                height: 50px;
                font-size: 24px;
            }

            #speedSlider {
                width: 80px;
            }

            .toolbar {
                flex-wrap: wrap;
                justify-content: center;
            }
        }

        .file-input-container {
            position: relative;
            overflow: hidden;
            display: inline-block;
            display: flex;
            width: 100%;
            margin-bottom: 8px;
        }

        .file-input-container input[type="file"] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
        }

        .file-input-button {
            padding: 8px 15px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: inline-block;
            display: block;
            width: 100%;
            padding: 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            text-align: center;
            margin: 4px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .file-name {
            margin-left: 10px;
            color: #666;
            margin-left: 10px;
            color: #666;
            background: white;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
            margin: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: block;
            width: 100%;
        }

        .editor-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
            min-height: 0; /* D≈Øle≈æit√© pro spr√°vn√© scrollov√°n√≠ */
        }

        .program-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            padding: 5px;
        }

        .program-list-item {
            flex: 0 0 auto;
            padding: 5px 10px;
            background: #f0f0f0;
            border-radius: 4px;
            cursor: pointer;
            white-space: nowrap;
            border: 1px solid #ddd;
        }

        .program-list-item:hover {
            background: #e0e0e0;
        }

        .program-list-item.active {
            background: #007bff;
            color: white;
            border-color: #0056b3;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 600px;
            border-radius: 8px;
            max-height: 70vh;
            overflow-y: auto;
        }

        .parameters-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .parameters-table th,
        .parameters-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .parameters-table th {
            background-color: #f5f5f5;
        }

        .close {
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: #f00;
        }

        .action-button {
            padding: 8px 16px;
            margin: 4px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .action-button:hover {
            background: #0056b3;
        }

        /* Upraven√© styly pro toolbar */
        .toolbar {
            display: flex;
            flex-direction: row;
            gap: 8px;
            padding: 8px;
            align-items: center;
        }

        .file-input-button {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 80px;
            font-size: 24px;
            flex: 1;
            background: #007bff;
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            padding: 0;
        }

        .action-button {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 80px;
            font-size: 24px;
            flex: 1;
            background: #007bff;
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            padding: 0;
        }

        .action-button:hover, .file-input-button:hover {
            background: #0056b3;
        }

        /* P≈ôidat styly pro touch za≈ô√≠zen√≠ */
        @media (hover: none) {
            .toolbar button, .file-input-button {
                min-height: 80px;
                font-size: 24px;
                touch-action: manipulation;
            }

            .toolbar {
                touch-action: none;
                user-select: none;
            }
        }

        /* P≈ôidat styly pro ikony */
        .button-icon {
            font-size: 32px;
            margin-bottom: 4px;
        }

        /* Upraven√© styly pro player controls */
        .controls-container {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            gap: 8px;
            background: none;
            border: none;
        }

        .player-container {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 2; /* Zvƒõt≈°it na dvojn√°sobek oproti ostatn√≠m tlaƒç√≠tk≈Øm */
        }

        .player-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .player-controls button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 120px; /* Zvƒõt≈°it ≈°√≠≈ôku tlaƒç√≠tek */
            min-height: 80px;
            font-size: 32px;
            flex: 1;
            background: #007bff;
            border: none;
            border-radius: 8px;
            color: white;
            padding: 0;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px; /* Zvƒõt≈°it p√≠smo */
            min-width: 150px; /* Minim√°ln√≠ ≈°√≠≈ôka pro poƒç√≠tadlo */
        }

        #speedSlider {
            width: 200px; /* Zvƒõt≈°it ≈°√≠≈ôku slideru */
            height: 40px;
        }

        .program-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            padding: 5px;
            width: 100%;
            background: #f5f5f5;
            border-bottom: 1px solid #ddd;
            min-height: 50px;
        }

        .player-container {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 3; /* Zvƒõt≈°it na trojn√°sobek */
            flex-wrap: wrap; /* Povolit zalamov√°n√≠ */
            padding: 8px;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px;
            min-width: 200px; /* Vƒõt≈°√≠ minim√°ln√≠ ≈°√≠≈ôka */
            margin-top: 8px; /* Odsazen√≠ shora */
            flex-direction: column; /* Informace pod sebe */
            align-items: flex-start;
        }

        #speedSlider {
            width: 250px; /* Vƒõt≈°√≠ ≈°√≠≈ôka slideru */
            height: 40px;
        }

        .program-list {
            padding: 10px;
            min-height: 60px; /* Vƒõt≈°√≠ minim√°ln√≠ v√Ω≈°ka */
        }

        .program-list-item {
            padding: 12px 16px; /* Vƒõt≈°√≠ padding */
            font-size: 18px; /* Vƒõt≈°√≠ p√≠smo */
            margin: 4px;
            min-width: 120px; /* Minim√°ln√≠ ≈°√≠≈ôka polo≈æky */
        }

        @media (max-width: 768px) {
            .player-container {
                padding: 12px;
            }

            .player-controls button {
                width: 80px; /* Vƒõt≈°√≠ ≈°√≠≈ôka tlaƒç√≠tek na mobilu */
                min-height: 80px;
            }

            .player-info {
                width: 100%; /* Na celou ≈°√≠≈ôku na mobilu */
                text-align: center;
                padding: 8px;
            }

            #speedSlider {
                width: 100%; /* Slider na celou ≈°√≠≈ôku */
                margin: 8px 0;
            }

            .program-list-item {
                flex: 1 1 auto; /* Lep≈°√≠ p≈ôizp≈Øsoben√≠ na mobilu */
                text-align: center;
                min-width: 150px; /* Vƒõt≈°√≠ minim√°ln√≠ ≈°√≠≈ôka na mobilu */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="simulator">
            <div class="canvas-container">
                <canvas id="simulatorCanvas"></canvas>
                <div class="position-info">
                    Aktu√°ln√≠: X: <span id="posX">0.000</span> Z: <span id="posZ">0.000</span><br>
                    Vybran√Ω: X: <span id="selectedPosX">-</span> Z: <span id="selectedPosZ">-</span>
                </div>
            </div>
        </div>
        <div class="toolbar">
            <label class="file-input-button">
                <span class="button-icon">üìÇ</span>
                <input type="file" id="actualFileInput" accept=".mpf,.spf" multiple style="display: none;">
            </label>
            <button onclick="window.simulator.resetView()" class="action-button">
                <span class="button-icon">üîÑ</span>
            </button>
            <button onclick="showParameters()" class="action-button">
                <span class="button-icon">R</span>
            </button>
            <div class="player-container">
                <button id="prevBtn" class="action-button" title="Krok zpƒõt">
                    <span class="button-icon">‚è™</span>
                </button>
                <button id="playBtn" class="action-button" title="P≈ôehr√°t/Pozastavit">
                    <span class="button-icon">‚ñ∂Ô∏è</span>
                </button>
                <button id="nextBtn" class="action-button" title="Krok vp≈ôed">
                    <span class="button-icon">‚è©</span>
                </button>
                <div class="player-info">
                    <input type="range" id="speedSlider" min="1" max="100" value="50" title="Rychlost p≈ôehr√°v√°n√≠">
                    <span>≈ò√°dek: <span id="currentLine">0</span>/<span id="totalLines">0</span></span>
                </div>
            </div>
        </div>
        <div class="program-list" id="programList"></div>
        <div class="editor-container">
            <div class="editor-wrapper">
                <textarea id="editor" spellcheck="false" placeholder="Vlo≈æte v√°≈° CNC program zde..."></textarea>
            </div>
        </div>
    </div>
    <div id="parametersModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeParametersModal()">&times;</span>
            <h2>Aktu√°ln√≠ hodnoty parametr≈Ø</h2>
            <table class="parameters-table">
                <thead>
                    <tr>
                        <th>Parametr</th>
                        <th>Hodnota</th>
                    </tr>
                </thead>
                <tbody id="parametersTableBody">
                </tbody>
            </table>
        </div>
    </div>
    <script>
        // Pomocn√© funkce pro optimalizaci
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function throttle(func, limit) {
            let inThrottle;
            return function(...args) {
                if (!inThrottle) {
                    func.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            }
        }

        // Optimalizovan√° debug funkce
        let debugCounter = 0;
        function debug(message) {
            console.log(`[${new Date().toLocaleTimeString()}] ${message}`);
        }

        // Inicializace z√°kladn√≠ch promƒõnn√Ωch
        const editor = document.getElementById('editor');
        const fileInput = document.getElementById('actualFileInput');
        const fileNameDisplay = document.getElementById('fileName');
        const posXElement = document.getElementById('posX');
        const posZElement = document.getElementById('posZ');
        const selectedPosXElement = document.getElementById('selectedPosX');
        const selectedPosZElement = document.getElementById('selectedPosZ');

        class CNCParser {
            constructor() {
                // Nejprve inicializovat mapy p≈ôed vol√°n√≠m reset()
                this.parameters = new Map();
                this.loadedSubprograms = new Map();
                this.baseDirectory = '';
                this.subprogramFiles = new Map(); // P≈ôidat cache pro soubory podprogram≈Ø
                this.loadedPrograms = new Map(); // Pro ukl√°d√°n√≠ v≈°ech naƒçten√Ωch program≈Ø

                // P≈ôednastaven√© parametry
                for (let i = 0; i <= 99; i++) {
                    this.parameters.set(`R${i}`, 0);
                }

                // A≈æ potom volat reset
                this.reset();
            }

            reset() {
                this.currentX = 0;
                this.currentZ = 0;
                this.absoluteMode = true;
                this.rapidMode = true;
                this.isFirstMove = true;
                this.lastArcCommand = null;

                // Reset parametr≈Ø - teƒè u≈æ v√≠me, ≈æe Map existuje
                if (this.parameters) {
                    this.parameters.clear();
                    for (let i = 0; i <= 99; i++) {
                        this.parameters.set(`R${i}`, 0);
                    }
                }

                debug('Parser resetov√°n');
            }

            // P≈ôidat metodu pro zpracov√°n√≠ R-parametr≈Ø
            evaluateParameters(expression) {
                try {
                    console.group('Parsov√°n√≠ parametr≈Ø z ≈ô√°dku:', expression);

                    // Odstranit koment√°≈ôe za st≈ôedn√≠kem a lom√≠tkem
                    const fullLine = expression.split(/[;/]/)[0].trim();

                    // Odstranit ƒç√≠slo ≈ô√°dku a p≈ô√≠padn√© mezery na zaƒç√°tku
                    const cleanLine = fullLine.replace(/^N\d+\s*/, '');

                    console.log('Vyƒçi≈°tƒõn√Ω ≈ô√°dek:', cleanLine);

                    // Upraven√Ω regex pro zachycen√≠ v≈°ech R-p≈ôi≈ôazen√≠ vƒçetnƒõ matematick√Ωch operac√≠
                    const rAssignment = cleanLine.match(/R(\d+)\s*=\s*(.+)/);

                    if (rAssignment) {
                        const [, paramNum, expression] = rAssignment;

                        try {
                            // Expandovat v≈°echny R-parametry ve v√Ωrazu
                            const expandedExpr = expression.replace(/R(\d+)/g, (match, num) => {
                                const value = this.parameters.get(`R${num}`);
                                return value !== undefined ? value : '0';
                            });

                            // Vyƒçistit v√Ωraz a odstranit p≈ô√≠padn√© z√°vorky
                            let cleanExpr = expandedExpr.replace(/^\(|\)$/g, '');

                            // Bezpeƒçnƒõ vyhodnotit v√Ωraz
                            const result = Function(`return ${cleanExpr}`)();
                            const numResult = Number(result);

                            if (!isNaN(numResult)) {
                                this.parameters.set(`R${paramNum}`, numResult);
                                console.log(`‚úì R${paramNum} = ${numResult} (v√Ωraz: ${expression})`);
                                return numResult;
                            } else {
                                console.warn(`‚úó Neplatn√Ω v√Ωsledek pro R${paramNum}: ${result}`);
                            }
                        } catch (e) {
                            console.warn(`‚úó Chyba p≈ôi vyhodnocen√≠ R${paramNum} = ${expression}:`, e);
                        }
                    }

                    console.groupEnd();
                    return 0;
                } catch (e) {
                    console.warn('Chyba p≈ôi zpracov√°n√≠ parametr≈Ø:', expression, e);
                    console.groupEnd();
                    return 0;
                }
            }

            parseCoordinate(value, current) {
                try {
                    // O≈°et≈ôen√≠ parametrick√Ωch v√Ωraz≈Ø
                    if (value.includes('=')) {
                        const expression = value.split('=')[1].trim();

                        // Nahradit R-parametry jejich hodnotami
                        const evaluatedExp = expression.replace(/R(\d+)/g, (match, number) => {
                            const paramValue = this.parameters.get(`R${number}`);
                            return paramValue !== undefined ? paramValue : '0';
                        });

                        // Bezpeƒçnƒõ vyhodnotit v√Ωraz
                        const result = Function(`return ${evaluatedExp}`)();
                        return Number(result.toFixed(3));
                    }

                    // Standardn√≠ zpracov√°n√≠ pro p≈ô√≠m√© hodnoty
                    const parsed = parseFloat(value);
                    if (isNaN(parsed)) return current;

                    const rounded = Number(parsed.toFixed(3));
                    return this.absoluteMode ? rounded : Number((current + rounded).toFixed(3));
                } catch (e) {
                    console.warn('Chyba p≈ôi parsov√°n√≠ sou≈ôadnice:', value, e);
                    return current;
                }
            }

            calculateArcPoints(start, end, center, isClockwise, resolution = 50) {
                const startAngle = Math.atan2(start.x - center.x, start.z - center.z);
                const endAngle = Math.atan2(end.x - center.x, end.z - center.z);

                let radius = Math.hypot(start.x - center.x, start.z - center.z);
                let angleStep;
                let points = [];

                // V√Ωpoƒçet √∫hlu v z√°vislosti na smƒõru
                let totalAngle = endAngle - startAngle;
                if (isClockwise) {
                    if (totalAngle >= 0) totalAngle -= 2 * Math.PI;
                } else {
                    if (totalAngle <= 0) totalAngle += 2 * Math.PI;
                }

                angleStep = totalAngle / resolution;

                // Generov√°n√≠ bod≈Ø na oblouku
                for (let i = 0; i <= resolution; i++) {
                    const angle = startAngle + angleStep * i;
                    const x = center.x + radius * Math.sin(angle);
                    const z = center.z + radius * Math.cos(angle);
                    points.push({ x: Number(x.toFixed(3)), z: Number(z.toFixed(3)) });
                }

                return points;
            }

            parseArcMovement(words, movement) {
                let hasCR = false;
                let hasAR = false;
                let arcRadius = 0;

                // Parametry pro Sinumerik 840D
                const params = {
                    CR: null,
                    AR: null,
                    I: null,
                    K: null,
                    I1: null,
                    K1: null,
                    CT: null,
                    TURN: 0
                };

                // Naƒçten√≠ v≈°ech parametr≈Ø
                for (let word of words) {
                    if (word.includes('=')) {
                        const [param, value] = word.split('=');
                        const numValue = parseFloat(value);
                        switch (param.toUpperCase()) {
                            case 'CR':
                                // CR je v≈ædy absolutn√≠ hodnota
                                params.CR = Math.abs(numValue);
                                hasCR = true;
                                break;
                            case 'AR': params.AR = numValue; break;
                            case 'TURN': params.TURN = parseInt(value); break;
                        }
                        continue;
                    }

                    const command = word[0];
                    const value = parseFloat(word.slice(1));
                    if (isNaN(value)) continue;

                    // D≈Øle≈æit√° zmƒõna: I,K jsou v≈ædy inkrement√°ln√≠ (relativn√≠ k poƒç√°teƒçn√≠mu bodu)
                    switch (command) {
                        case 'I':
                            // I je v≈ædy relativn√≠ k poƒç√°teƒçn√≠mu bodu
                            params.I = movement.fromX + value;
                            break;
                        case 'K':
                            // K je v≈ædy relativn√≠ k poƒç√°teƒçn√≠mu bodu
                            params.K = movement.fromZ + value;
                            break;
                        case 'I1':
                            // I1 je tak√© relativn√≠
                            params.I1 = movement.fromX + value;
                            break;
                        case 'K1':
                            // K1 je tak√© relativn√≠
                            params.K1 = movement.fromZ + value;
                            break;
                    }
                }

                const startPoint = { x: movement.fromX, z: movement.fromZ };
                const endPoint = { x: movement.toX, z: movement.toZ };
                let centerPoint = { x: 0, z: 0 };

                // Urƒçen√≠ st≈ôedu oblouku podle priority parametr≈Ø
                if (params.I !== null && params.K !== null) {
                    // St≈ôed je nyn√≠ v≈ædy relativn√≠ k poƒç√°teƒçn√≠mu bodu
                    centerPoint = { x: params.I, z: params.K };
                } else if (params.I1 !== null && params.K1 !== null) {
                    centerPoint = { x: params.I1, z: params.K1 };
                } else if (hasCR) {
                    // V√Ωpoƒçet st≈ôedu pomoc√≠ polomƒõru CR
                    const chord = Math.hypot(endPoint.x - startPoint.x, endPoint.z - startPoint.z);
                    if (params.CR < chord / 2) {
                        console.warn('CR je p≈ô√≠li≈° mal√Ω, pou≈æije se minim√°ln√≠ mo≈æn√Ω polomƒõr');
                        params.CR = chord / 2;
                    }

                    // V√Ωpoƒçet st≈ôed≈Ø - existuj√≠ dva mo≈æn√© st≈ôedy
                    const h = Math.sqrt(params.CR * params.CR - (chord * chord / 4));
                    const midX = (startPoint.x + endPoint.x) / 2;
                    const midZ = (startPoint.z + endPoint.z) / 2;

                    // Smƒõrov√Ω vektor kolm√Ω na tƒõtivu
                    const dirX = (startPoint.z - endPoint.z) / chord;
                    const dirZ = (endPoint.x - startPoint.x) / chord;

                    // Vypoƒç√≠tat oba mo≈æn√© st≈ôedy
                    const center1 = {
                        x: midX + h * dirX,
                        z: midZ + h * dirZ
                    };

                    const center2 = {
                        x: midX - h * dirX,
                        z: midZ - h * dirZ
                    };

                    // Vypoƒç√≠tat √∫hly pro oba st≈ôedy
                    const angle1 = this.calculateTotalAngle(startPoint, endPoint, center1, movement.type === 'G2');
                    const angle2 = this.calculateTotalAngle(startPoint, endPoint, center2, movement.type === 'G2');

                    // Vybrat st≈ôed, kter√Ω d√°v√° men≈°√≠ √∫hel (men≈°√≠ oblouk)
                    centerPoint = Math.abs(angle1) <= Math.abs(angle2) ? center1 : center2;

                    console.log('V√Ωpoƒçet oblouku:', {
                        type: movement.type,
                        radius: params.CR,
                        chord: chord,
                        height: h,
                        angles: {
                            center1: angle1 * 180 / Math.PI,
                            center2: angle2 * 180 / Math.PI
                        },
                        selectedCenter: Math.abs(angle1) <= Math.abs(angle2) ? 'center1' : 'center2'
                    });
                }

                // V√Ωpoƒçet bod≈Ø na oblouku
                const radius = Math.hypot(startPoint.x - centerPoint.x, startPoint.z - centerPoint.z);
                const startAngle = Math.atan2(startPoint.x - centerPoint.x, startPoint.z - centerPoint.z);
                let endAngle = Math.atan2(endPoint.x - centerPoint.x, endPoint.z - centerPoint.z);

                // Upravit √∫hel podle smƒõru a poƒçtu ot√°ƒçek
                if (movement.type === 'G2') { // CW
                    if (endAngle >= startAngle) endAngle -= 2 * Math.PI;
                    endAngle -= 2 * Math.PI * (params.TURN || 0);
                } else { // CCW (G3)
                    if (endAngle <= startAngle) endAngle += 2 * Math.PI;
                    endAngle += 2 * Math.PI * (params.TURN || 0);
                }

                // Vygenerovat body oblouku
                const points = [];
                const steps = Math.max(50, Math.abs(endAngle - startAngle) * 20);
                const angleStep = (endAngle - startAngle) / steps;

                for (let i = 0; i <= steps; i++) {
                    const angle = startAngle + angleStep * i;
                    const x = centerPoint.x + radius * Math.sin(angle);
                    const z = centerPoint.z + radius * Math.cos(angle);
                    points.push({
                        x: Number(x.toFixed(3)),
                        z: Number(z.toFixed(3))
                    });
                }

                return {
                    points: points,
                    center: centerPoint // Vr√°tit i st≈ôed oblouku
                };
            }

            calculateTotalAngle(start, end, center, isClockwise) {
                const startAngle = Math.atan2(start.x - center.x, start.z - center.z);
                let endAngle = Math.atan2(end.x - center.x, end.z - center.z);
                let totalAngle = endAngle - startAngle;

                // Upravit √∫hel podle smƒõru
                if (isClockwise) {
                    if (totalAngle > 0) totalAngle -= 2 * Math.PI;
                } else {
                    if (totalAngle < 0) totalAngle += 2 * Math.PI;
                }

                return totalAngle;
            }

            async parseLine(line) {
                // Kontrola vol√°n√≠ podprogramu
                const lMatch = line.trim().match(/L(\d+)/i);
                if (lMatch) {
                    const subprogramNumber = parseInt(lMatch[1]);
                    await this.processSubprogramParameters(subprogramNumber);
                    return null; // P≈ôeskoƒçit tento ≈ô√°dek v hlavn√≠m zpracov√°n√≠
                }

                // Nejprve vyƒçistit ≈ô√°dek a p≈ôidat mezery mezi G-k√≥dy a sou≈ôadnice
                const cleanedLine = line.trim()
                    .toUpperCase()
                    .replace(/G0(?=[XZ])/g, 'G0 ')  // P≈ôidat mezeru po G0 p≈ôed X nebo Z
                    .replace(/G1(?=[XZ])/g, 'G1 ')  // P≈ôidat mezeru po G1 p≈ôed X nebo Z
                    .replace(/G91(?=[XZ])/g, 'G91 ') // P≈ôidat mezeru po G91 p≈ôed X nebo Z
                    .replace(/G90(?=[XZ])/g, 'G90 '); // P≈ôidat mezeru po G90 p≈ôed X nebo Z

                // P≈ôidat zpracov√°n√≠ p≈ôi≈ôazen√≠ R-parametr≈Ø
                if (cleanedLine.includes('=')) {
                    const match = cleanedLine.match(/R(\d+)\s*=\s*(.+)/);
                    if (match) {
                        const [, paramNum, expression] = match;
                        const value = this.evaluateParameters(expression);
                        this.parameters.set(`R${paramNum}`, value);
                        return null; // ≈ò√°dek obsahoval pouze p≈ôi≈ôazen√≠ parametru
                    }
                }

                const words = cleanedLine.split(/\s+/);
                if (words.length === 0) return null;

                console.group(`Parsov√°n√≠ ≈ô√°dku: ${line}`);

                const movement = {
                    fromX: this.currentX,
                    fromZ: this.currentZ,
                    toX: this.currentX,
                    toZ: this.currentZ,
                    rapid: this.rapidMode,
                    // P≈ôid√°n√≠ vlastnost√≠ pro st≈ôedy a body oblouku
                    center: null,
                    arcPoints: null,
                    isArc: false,
                    type: this.lastArcCommand // Pou≈æ√≠t posledn√≠ G2/G3 pokud existuje
                };

                let hasMove = false;
                let hasGCommand = false; // Sledovat, zda byl na ≈ô√°ku G p≈ô√≠kaz

                for (let word of words) {
                    if (!word) continue;
                    const command = word[0];
                    let value = word.slice(1);

                    // Upravit zpracov√°n√≠ pro sou≈ôadnice obsahuj√≠c√≠ =
                    if (command === 'X' || command === 'Z') {
                        if (value.includes('=')) {
                            value = '=' + value.split('=')[1];  // Zachovat = pro matematick√Ω v√Ωraz
                        }
                    }

                    switch (command) {
                        case 'G':
                            hasGCommand = true;
                            switch (value) {
                                case '0':
                                    this.rapidMode = true;
                                    movement.rapid = true;
                                    console.log('‚úì Nastaven rychloposuv (G0)');
                                    break;
                                case '1':
                                    this.rapidMode = false;
                                    movement.rapid = false;
                                    console.log('‚úì Nastaven pracovn√≠ posuv (G1)');
                                    break;
                                case '90':
                                    this.absoluteMode = true;
                                    console.log('‚úì Nastaveno absolutn√≠ programov√°n√≠ (G90)');
                                    break;
                                case '91':
                                    this.absoluteMode = false;
                                    console.log('‚úì Nastaveno p≈ô√≠r≈Østkov√© programov√°n√≠ (G91)');
                                    break;
                                case '2':
                                    this.rapidMode = false;
                                    this.lastArcCommand = 'G2';
                                    movement.type = 'G2'; // CW
                                    movement.isArc = true;
                                    console.log('‚úì Nastaven oblouk ve smƒõru hodin (G2)');
                                    break;
                                case '3':
                                    this.rapidMode = false;
                                    this.lastArcCommand = 'G3';
                                    movement.type = 'G3'; // CCW
                                    movement.isArc = true;
                                    console.log('‚úì Nastaven oblouk proti smƒõru hodin (G3)');
                                    break;
                            }
                            break;
                        case 'X':
                            movement.toX = this.parseCoordinate(value, this.currentX);
                            hasMove = true;
                            this.currentX = movement.toX;
                            console.log(`‚ûú X pozice: ${movement.toX}`);
                            break;
                        case 'Z':
                            movement.toZ = this.parseCoordinate(value, this.currentZ);
                            hasMove = true;
                            this.currentZ = movement.toZ;
                            console.log(`‚ûú Z pozice: ${movement.toZ}`);
                            break;
                    }
                }

                // Pokud je CR parametr a nen√≠ G p≈ô√≠kaz, pou≈æ√≠t posledn√≠ G2/G3
                if (!hasGCommand && words.some(w => w.startsWith('CR='))) {
                    movement.isArc = true;
                    console.log(`‚úì Pou≈æit p≈ôedchoz√≠ p≈ô√≠kaz (${this.lastArcCommand})`);
                }

                // Po zpracov√°n√≠ v≈°ech sou≈ôadnic zpracovat oblouk
                if (hasMove && (movement.type === 'G2' || movement.type === 'G3')) {
                    const arcResult = this.parseArcMovement(words, movement);
                    movement.arcPoints = arcResult.points;
                    movement.center = arcResult.center; // Ulo≈æit st≈ôed do pohybu
                }

                // P≈ôidat koncov√© body do pamƒõti
                if (hasMove) {
                    // Pro oblouk p≈ôidat v≈°echny body vƒçetnƒõ koncov√©ho
                    if (movement.arcPoints && movement.arcPoints.length > 0) {
                        movement.points = [...movement.arcPoints];
                    } else {
                        // Pro p≈ô√≠m√Ω pohyb p≈ôidat koncov√Ω bod
                        movement.points = [{
                            x: movement.toX,
                            z: movement.toZ
                        }];
                    }
                }

                if (hasMove) {
                    console.log(`‚Æï Pohyb: X${movement.toX} Z${movement.toZ} ${movement.rapid ? '(rapid)' : '(work)'}`);
                }

                console.groupEnd();
                return hasMove ? movement : null;
            }

            async parseProgram(program) {
                this.reset();
                const lines = program.split('\n');
                const movements = [];

                // Nejprve proj√≠t program a naƒç√≠st v≈°echny podprogramy
                for (const line of lines) {
                    const lMatch = line.trim().match(/L(\d+)/i);
                    if (lMatch) {
                        const subprogramNumber = parseInt(lMatch[1]);
                        await this.processSubprogramParameters(subprogramNumber);
                    }
                }

                // Pak zpracovat pohyby
                for (const line of lines) {
                    if (line.trim() === '') continue;
                    const movement = await this.parseLine(line);
                    if (movement) {
                        movements.push(movement);
                    }
                }

                debug(`Celkem pohyb≈Ø: ${movements.length}`);
                return movements;
            }

            // P≈ôidat metodu pro nastaven√≠ z√°kladn√≠ho adres√°≈ôe
            setBaseDirectory(path) {
                // Odstranit p≈ô√≠padn√© uvozovky a upravit cestu
                this.baseDirectory = path.replace(/["']/g, '').trim();
                console.log(`Nastavena cesta k podprogram≈Øm: ${this.baseDirectory}`);
            }

            // P≈ôidat metodu pro naƒçten√≠ podprogramu
            async loadSubprogram(number) {
                const baseName = `L${number}`;
                const filename = `${baseName}.SPF`;

                // 1. Nejprve zkusit naj√≠t v ji≈æ naƒçten√Ωch programech
                const foundProgram = Array.from(this.loadedPrograms.values())
                    .find(prog => prog.file.name.toUpperCase().startsWith(baseName));
                if (foundProgram) {
                    return foundProgram.content;
                }

                // 2. Pokud nen√≠ v naƒçten√Ωch programech, zkusit cache
                if (this.loadedSubprograms.has(baseName)) {
                    return this.loadedSubprograms.get(baseName);
                }

                // 3. Pokud nen√≠ ani v cache, zkusit naj√≠t v seznamu soubor≈Ø
                const file = this.subprogramFiles.get(baseName);
                if (!file) {
                    console.warn(`Podprogram ${baseName} nenalezen v naƒçten√Ωch souborech`);
                    return null;
                }

                try {
                    const content = await this.readFile(file);
                    this.loadedSubprograms.set(baseName, content);
                    return content;
                } catch (error) {
                    console.warn(`Nelze naƒç√≠st podprogram ${filename}:`, error);
                    return null;
                }
            }

            // Pomocn√° metoda pro ƒçten√≠ souboru
            readFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = (e) => reject(e);
                    reader.readAsText(file);
                });
            }

            // P≈ôidat metodu pro naƒçten√≠ podprogram≈Ø ze slo≈æky
            async loadSubprogramDirectory(fileList) {
                this.subprogramFiles.clear();
                for (let file of fileList) {
                    if (file.name.toUpperCase().endsWith('.SPF')) {
                        // Ukl√°dat bez p≈ô√≠pony .SPF
                        const baseName = file.name.toUpperCase().replace(/\.SPF$/, '');
                        this.subprogramFiles.set(baseName, file);
                    }
                }
                console.log('Naƒçten√© podprogramy:', Array.from(this.subprogramFiles.keys()));
            }

            // Upraven√° metoda pro zpracov√°n√≠ parametr≈Ø z podprogramu
            async processSubprogramParameters(subprogramNumber) {
                const content = await this.loadSubprogram(subprogramNumber);
                if (!content) return;

                // Zpracovat ≈ô√°dky podprogramu a naj√≠t definice parametr≈Ø
                const lines = content.split('\n');
                for (const line of lines) {
                    const trimmedLine = line.trim().toUpperCase();

                    // Kontrola zda ≈ô√°dek obsahuje R-parametry
                    if (trimmedLine.includes('R') && trimmedLine.includes('=')) {
                        // Nejprve odstranit koment√°≈ôe
                        const lineWithoutComments = trimmedLine.split(/[;/]/)[0].trim();

                        // Odstranit ƒç√≠slo bloku na zaƒç√°tku (nap≈ô. N85)
                        const cleanLine = lineWithoutComments.replace(/^N\d+\s*/, '');

                        // Naj√≠t v≈°echna p≈ôi≈ôazen√≠ R-parametr≈Ø na ≈ô√°dku
                        const rAssignments = cleanLine.matchAll(/R(\d+)\s*=\s*(\([^)]+\)|[-]?\d+\.?\d*)/g);

                        // Zpracovat v≈°echna nalezen√° p≈ôi≈ôazen√≠
                        for (const match of rAssignments) {
                            const [, paramNum, expression] = match;
                            try {
                                // Vyƒçistit v√Ωraz a vyhodnotit
                                let cleanExpr = expression.replace(/^\(|\)$/g, '');

                                // Expandovat p≈ô√≠padn√© R-parametry ve v√Ωrazu
                                const expandedExpr = cleanExpr.replace(/R(\d+)/g, (match, num) => {
                                    const value = this.parameters.get(`R${num}`);
                                    return value !== undefined ? value : '0';
                                });

                                // Vyhodnotit v√Ωraz
                                const result = Function(`return ${expandedExpr}`)();
                                const numResult = Number(result);

                                if (!isNaN(numResult)) {
                                    this.parameters.set(`R${paramNum}`, numResult);
                                    console.log(`‚úì Podprogram L${subprogramNumber}: R${paramNum} = ${numResult} (${cleanLine})`);
                                }
                            } catch (e) {
                                console.warn(`‚úó Chyba p≈ôi zpracov√°n√≠ parametru v podprogramu L${subprogramNumber}:`, e);
                            }
                        }
                    }
                }
            }

            // P≈ôidat metodu pro naƒçten√≠ programu
            async loadProgram(file) {
                try {
                    const content = await this.readFile(file);
                    // Ulo≈æit do obou map pro snadn√© hled√°n√≠
                    const upperName = file.name.toUpperCase();
                    this.loadedPrograms.set(file.name, {
                        content: content,
                        file: file
                    });
                    // Pokud jde o .SPF soubor, ulo≈æit i do mapy podprogram≈Ø
                    if (upperName.endsWith('.SPF')) {
                        this.subprogramFiles.set(upperName, file);
                    }
                    return content;
                } catch (error) {
                    console.warn(`Nelze naƒç√≠st program ${file.name}:`, error);
                    return null;
                }
            }

            // P≈ôidat metodu pro z√≠sk√°n√≠ naƒçten√©ho programu
            getProgram(name) {
                return this.loadedPrograms.get(name)?.content || null;
            }

            // P≈ôidat metodu pro z√≠sk√°n√≠ seznamu program≈Ø
            getProgramList() {
                return Array.from(this.loadedPrograms.keys());
            }

            // Upravit metodu findLineByPoint pro lep≈°√≠ detekci
            findLineByPoint(targetX, targetZ) {
                const lines = editor.value.split('\n');
                let isAbsolute = true;
                let currentX = 0;
                let currentZ = 0;
                const tolerance = 0.001;

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();

                    // Kontrola G90/G91
                    if (line.match(/G90/i)) isAbsolute = true;
                    if (line.match(/G91/i)) isAbsolute = false;

                    // Kontrola parametrick√Ωch sou≈ôadnic
                    const paramMatch = line.match(/[XZ]=R\d+[+-]?\d*\.?\d*/ig);
                    if (paramMatch) {
                        // Vyhodnotit parametrick√© v√Ωrazy
                        for (const coord of paramMatch) {
                            const [axis, expr] = coord.split('=');
                            const value = this.evaluateParameters(expr);
                            if (axis === 'X') currentX = value;
                            if (axis === 'Z') currentZ = value;
                        }
                    } else {
                        // Standardn√≠ sou≈ôadnice
                        const xMatch = line.match(/X(-?\d+\.?\d*)/i);
                        const zMatch = line.match(/Z(-?\d+\.?\d*)/i);

                        if (xMatch) {
                            const x = Number(parseFloat(xMatch[1]).toFixed(3));
                            currentX = isAbsolute ? x : Number((currentX + x).toFixed(3));
                        }
                        if (zMatch) {
                            const z = Number(parseFloat(zMatch[1]).toFixed(3));
                            currentZ = isAbsolute ? z : Number((currentZ + z).toFixed(3));
                        }
                    }

                    // Kontrola shody s c√≠lov√Ωm bodem
                    if (Math.abs(currentX - targetX) < tolerance &&
                        Math.abs(currentZ - targetZ) < tolerance) {
                        return i;
                    }
                }
                return -1;
            }

            parseCoordinates(line) {
                const result = {
                    hasCoordinates: false,
                    x: this.currentX,
                    z: this.currentZ
                };

                // Ignorovat pr√°zdn√© ≈ô√°dky a koment√°≈ôe
                if (!line || line.trim().startsWith(';')) {
                    return result;
                }

                try {
                    const cleanLine = line.trim().toUpperCase();

                    // Aktualizovat G90/G91 m√≥d
                    if (cleanLine.includes('G90')) this.absoluteMode = true;
                    if (cleanLine.includes('G91')) this.absoluteMode = false;

                    // Zpracovat parametrick√© sou≈ôadnice (X=R... Z=R...)
                    const paramMatch = cleanLine.match(/[XZ]=R\d+[+-]?\d*\.?\d*/ig);
                    if (paramMatch) {
                        for (const coord of paramMatch) {
                            const [axis, expr] = coord.split('=');
                            const value = this.evaluateParameters(expr);
                            if (axis === 'X') result.x = value;
                            if (axis === 'Z') result.z = value;
                            result.hasCoordinates = true;
                        }
                    }

                    // Zpracovat p≈ô√≠m√© sou≈ôadnice (X... Z...)
                    const xMatch = cleanLine.match(/X(-?\d+\.?\d*)/);
                    const zMatch = cleanLine.match(/Z(-?\d+\.?\d*)/);

                    if (xMatch) {
                        const x = Number(parseFloat(xMatch[1]).toFixed(3));
                        result.x = this.absoluteMode ? x : this.currentX + x;
                        result.hasCoordinates = true;
                    }

                    if (zMatch) {
                        const z = Number(parseFloat(zMatch[1]).toFixed(3));
                        result.z = this.absoluteMode ? z : this.currentZ + z;
                        result.hasCoordinates = true;
                    }

                    // Logov√°n√≠ nalezen√Ωch sou≈ôadnic
                    if (result.hasCoordinates) {
                        console.log(`Nalezeny sou≈ôadnice v ≈ô√°dku "${line}":`, {
                            X: result.x,
                            Z: result.z,
                            absolutn√≠: this.absoluteMode
                        });
                    }

                } catch (e) {
                    console.warn('Chyba p≈ôi parsov√°n√≠ sou≈ôadnic:', e);
                }

                return result;
            }
        }

        class Simulator {
            constructor() {
                this.canvas = document.getElementById('simulatorCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.parser = new CNCParser();
                this.setupCanvas();
                this.gridCache = null;
                this.lastUpdate = 0;
                this.updateThreshold = 50; // ms
                this.minScale = 0.1; // minim√°ln√≠ mƒõ≈ô√≠tko
                this.padding = 50; // pixely pro okraj
                this.maxScale = 10; // maxim√°ln√≠ mƒõ≈ô√≠tko
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                this.isDragging = false;
                this.baseScale = 1;
                this.zoomFactor = 1;
                this.viewPosition = { x: 0, y: 0 }; // P≈ôid√°me sledov√°n√≠ pozice pohledu
                this.programBounds = null; // P≈ôid√°me ukl√°d√°n√≠ hranic programu
                this.originX = 0; // Skuteƒçn√° pozice poƒç√°tku v sou≈ôadnic√≠ch CNC
                this.originY = 0; // Skuteƒçn√° pozice poƒç√°tku v sou≈ôadnic√≠ch CNC

                // P≈ôid√°n√≠ event listener≈Ø pro ovl√°d√°n√≠
                this.canvas.addEventListener('wheel', this.handleZoom.bind(this));
                this.canvas.addEventListener('mousedown', this.startDrag.bind(this));
                this.canvas.addEventListener('mousemove', this.drag.bind(this));
                this.canvas.addEventListener('mouseup', this.stopDrag.bind(this));
                this.canvas.addEventListener('mouseleave', this.stopDrag.bind(this));

                // P≈ôid√°n√≠ podpory pro dotykov√© ovl√°d√°n√≠
                this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));

                // Promƒõnn√© pro multi-touch zoom
                this.lastTouchDistance = 0;
                this.touchZoomStartScale = 1;

                window.addEventListener('resize', () => this.setupCanvas());
                debug('Simul√°tor inicializov√°n');

                // P≈ôid√°n√≠ event listener≈Ø pro tooltip
                this.tooltip = document.createElement('div');
                this.tooltip.className = 'tooltip';
                document.querySelector('.canvas-container').appendChild(this.tooltip);
                this.tooltip.style.display = 'none';
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseout', () => this.tooltip.style.display = 'none');

                // Ulo≈æen√≠ bod≈Ø pro pozdƒõj≈°√≠ detekci
                this.points = [];

                // P≈ôidat k≈ô√≠≈æek pro mobiln√≠ za≈ô√≠zen√≠
                this.crosshair = document.createElement('div');
                this.crosshair.className = 'crosshair';
                document.querySelector('.canvas-container').appendChild(this.crosshair);

                // P≈ôidat promƒõnn√© pro dlouh√Ω stisk
                this.longPressTimeout = null;
                this.isLongPress = false;

                // P≈ôidat handlery pro dlouh√Ω stisk
                this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
                this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });

                this.lastSelectedPoint = null; // P≈ôid√°me promƒõnnou pro uchov√°n√≠ posledn√≠ho vybran√©ho bodu
                this.highlightedPoint = null; // Pro sledov√°n√≠ zv√Ωraznƒõn√©ho bodu
                this.pulseAnimation = null; // Pro animaci

                // P≈ôidat event listener pro kliknut√≠ na canvas
                this.canvas.addEventListener('click', this.handleCanvasClick.bind(this));

                // Vylep≈°it touch podporu
                this.canvas.style.touchAction = 'none';
                this.lastTouchDistance = 0;
                this.touchStartX = 0;
                this.touchStartY = 0;

                // P≈ôidat event listenery pro lep≈°√≠ touch ovl√°d√°n√≠
                this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
            }

            handleZoom(event) {
                event.preventDefault();
                const oldZoom = this.zoomFactor;
                const zoomSpeed = 0.1;
                const rect = this.canvas.getBoundingClientRect();
                // Z√≠skat pozici my≈°i vzhledem ke canvasu p≈ôed zoomem
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                // Vypoƒç√≠tat pozici my≈°i v sou≈ôadnic√≠ch svƒõta p≈ôed zoomem
                const worldX = (mouseX - this.centerX) / (this.baseScale * this.zoomFactor);
                const worldY = (this.centerY - mouseY) / (this.baseScale * this.zoomFactor);

                // Upravit zoom faktor
                if (event.deltaY < 0) {
                    this.zoomFactor = Math.min(this.zoomFactor * (1 + zoomSpeed), 10);
                } else {
                    this.zoomFactor = Math.max(this.zoomFactor * (1 - zoomSpeed), 0.1);
                }

                // Aktualizovat scale
                this.scale = this.baseScale * this.zoomFactor;

                // P≈ôepoƒç√≠tat novou pozici st≈ôedu pro zachov√°n√≠ bodu pod my≈°√≠
                this.centerX = mouseX - worldX * this.scale;
                this.centerY = mouseY + worldY * this.scale;
                this.gridCache = this.createGridCache();
                this.simulate(false); // false znamen√°, ≈æe nechceme resetovat pohled
            }

            startDrag(event) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                // Kontrola, zda neklik√°me na bod
                const hitPoint = this.points.find(point => {
                    const dx = mouseX - point.screenX;
                    const dy = mouseY - point.screenY;
                    return Math.sqrt(dx * dx + dy * dy) < 5;
                });

                if (!hitPoint) {
                    this.isDragging = true;
                    this.lastMouseX = event.clientX;
                    this.lastMouseY = event.clientY;
                    this.canvas.style.cursor = 'grabbing';
                }
            }

            drag(event) {
                if (!this.isDragging) return;
                const deltaX = event.clientX - this.lastMouseX;
                const deltaY = event.clientY - this.lastMouseY;

                this.centerX += deltaX;
                this.centerY += deltaY;

                this.lastMouseX = event.clientX;
                this.lastMouseY = event.clientY;

                // P≈ôekreslit m≈ô√≠≈æku p≈ôi ka≈æd√©m posunu
                this.gridCache = this.createGridCache();
                this.simulate();
            }

            stopDrag() {
                // P≈ôidat mal√© zpo≈ædƒõn√≠ pro kontrolu, zda ≈°lo o klik nebo tah
                setTimeout(() => {
                    this.isDragging = false;
                    this.canvas.style.cursor = 'default';
                    // Zajistit p≈ôekreslen√≠ drah
                    if (this.lastMovements) {
                        this.drawPath(this.lastMovements);
                    }
                }, 50);
            }

            handleTouchStart(event) {
                event.preventDefault();

                if (event.touches.length === 2) {
                    // Zoom pomoc√≠ dvou prst≈Ø
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];
                    this.lastTouchDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    this.touchZoomStartScale = this.zoomFactor;
                } else if (event.touches.length === 1) {
                    // Posouv√°n√≠ jedn√≠m prstem
                    const touch = event.touches[0];
                    this.touchStartX = touch.clientX;
                    this.touchStartY = touch.clientY;
                    this.isDragging = true;
                }
            }

            handleTouchMove(event) {
                event.preventDefault();

                if (event.touches.length === 2) {
                    // Zoom
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];
                    const distance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );

                    const scale = distance / this.lastTouchDistance;
                    this.zoomFactor = Math.min(Math.max(this.touchZoomStartScale * scale, 0.1), 10);
                    this.scale = this.baseScale * this.zoomFactor;

                    // Aktualizovat zobrazen√≠
                    this.gridCache = this.createGridCache();
                    this.simulate(false);
                } else if (event.touches.length === 1 && this.isDragging) { // Opraveno 'and' na '&&'
                    // Posouv√°n√≠
                    const touch = event.touches[0];
                    const deltaX = touch.clientX - this.touchStartX;
                    const deltaY = touch.clientY - this.touchStartY;

                    this.centerX += deltaX;
                    this.centerY += deltaY;

                    this.touchStartX = touch.clientX;
                    this.touchStartY = touch.clientY;

                    // Aktualizovat zobrazen√≠
                    this.gridCache = this.createGridCache();
                    this.simulate();
                }

                // P≈ôidat pr≈Øbƒõ≈æn√© p≈ôekreslov√°n√≠ bƒõhem pohybu
                if (this.lastMovements) {
                    requestAnimationFrame(() => {
                        this.drawPath(this.lastMovements);
                    });
                }
            }

            handleTouchEnd(event) {
                this.isDragging = false;
                this.lastTouchDistance = 0;

                // P≈ôidat vynucen√© p≈ôekreslen√≠ po pu≈°tƒõn√≠
                setTimeout(() => {
                    if (this.lastMovements) {
                        this.drawPath(this.lastMovements);
                    }
                }, 50);
            }

            setupCanvas() {
                this.canvas.width = this.canvas.parentElement.clientWidth;
                this.canvas.height = this.canvas.parentElement.clientHeight;
                this.centerX = this.canvas.width / 2;
                this.centerY = this.canvas.height / 2;
                this.scale = Math.min(this.canvas.width, this.canvas.height) / 200;
                this.gridCache = this.createGridCache();
                this.simulate();
            }

            getGridStep() {
                const scale = this.scale * this.zoomFactor;
                const minPixelsBetweenLines = 50; // Minim√°ln√≠ poƒçet pixel≈Ø mezi ƒçarami m≈ô√≠≈æky
                const steps = [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000];
                const idealStep = minPixelsBetweenLines / scale;

                for (let step of steps) {
                    if (step * scale >= minPixelsBetweenLines * 0.8) {
                        return step;
                    }
                }
                return steps[steps.length - 1];
            }

            createGridCache() {
                const cacheCanvas = document.createElement('canvas');
                cacheCanvas.width = this.canvas.width;
                cacheCanvas.height = this.canvas.height;
                const ctx = cacheCanvas.getContext('2d');

                // Vykreslen√≠ m≈ô√≠≈æky
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 0.5;
                ctx.fillStyle = '#666';
                ctx.font = '22px Arial'; /* Zvƒõt≈°eno z 11px */
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';

                const gridStep = this.getGridStep();
                const origin = this.worldToScreen(0, 0);

                // V√Ωpoƒçet rozsahu m≈ô√≠≈æky s rezervou
                const viewportLeft = -this.centerX / this.scale - gridStep;
                const viewportRight = (this.canvas.width - this.centerX) / this.scale + gridStep;
                const viewportTop = (this.centerY) / this.scale + gridStep;
                const viewportBottom = -(this.canvas.height - this.centerY) / this.scale - gridStep;

                // Zaokrouhlen√≠ na nejbli≈æ≈°√≠ n√°sobek gridStep
                const startX = Math.floor(viewportLeft / gridStep) * gridStep;
                const endX = Math.ceil(viewportRight / gridStep) * gridStep;
                const startY = Math.floor(viewportBottom / gridStep) * gridStep;
                const endY = Math.ceil(viewportTop / gridStep) * gridStep;

                // Vytvo≈ôen√≠ seznamu hlavn√≠ch a vedlej≈°√≠ch ƒçar
                const mainLines = [];
                const subLines = [];

                // Vykreslen√≠ vertik√°ln√≠ch ƒçar (nyn√≠ osa X)
                for (let x = startX; x <= endX; x += gridStep) {
                    const screenX = this.worldToScreen(x, 0).x;
                    const isMainLine = Math.abs(x % (gridStep * 5)) < 0.001;
                    if (isMainLine) {
                        mainLines.push(() => {
                            ctx.strokeStyle = '#aaa';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(screenX, 0);
                            ctx.lineTo(screenX, this.canvas.height);
                            ctx.stroke();
                            // Zmƒõnit popisek z Z na X
                            if (Math.abs(x) > 0.001) {
                                ctx.fillText(`X${x}`, screenX + 8, this.canvas.height - 20);
                            }
                        });
                    } else {
                        subLines.push(() => {
                            ctx.strokeStyle = '#ddd';
                            ctx.lineWidth = 0.5;
                            ctx.beginPath();
                            ctx.moveTo(screenX, 0);
                            ctx.lineTo(screenX, this.canvas.height);
                            ctx.stroke();
                        });
                    }
                }

                // Vykreslen√≠ horizont√°ln√≠ch ƒçar (nyn√≠ osa Z)
                for (let y = startY; y <= endY; y += gridStep) {
                    const screenY = this.worldToScreen(0, y).y;
                    const isMainLine = Math.abs(y % (gridStep * 5)) < 0.001;
                    if (isMainLine) {
                        mainLines.push(() => {
                            ctx.strokeStyle = '#aaa';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(0, screenY);
                            ctx.lineTo(this.canvas.width, screenY);
                            ctx.stroke();
                            // Zmƒõnit popisek z X na Z
                            if (Math.abs(y) > 0.001) {
                                ctx.fillText(`Z${y}`, 8, screenY + 8);
                            }
                        });
                    } else {
                        subLines.push(() => {
                            ctx.strokeStyle = '#ddd';
                            ctx.lineWidth = 0.5;
                            ctx.beginPath();
                            ctx.moveTo(0, screenY);
                            ctx.lineTo(this.canvas.width, screenY);
                            ctx.stroke();
                        });
                    }
                }

                // Nejprve vykreslit vedlej≈°√≠ ƒç√°ry
                subLines.forEach(drawFn => drawFn());
                // Pak vykreslit hlavn√≠ ƒç√°ry a popisky
                mainLines.forEach(drawFn => drawFn());

                return cacheCanvas;
            }

            drawAxes() {
                if (this.gridCache) {
                    this.ctx.drawImage(this.gridCache, 0, 0);
                }

                const origin = this.worldToScreen(0, 0);

                // Vykreslen√≠ os
                this.ctx.strokeStyle = '#000';
                this.ctx.lineWidth = 2;

                // X osa (horizont√°ln√≠)
                this.ctx.beginPath();
                this.ctx.moveTo(0, origin.y);
                this.ctx.lineTo(this.canvas.width, origin.y);
                this.ctx.stroke();

                // Z osa (vertik√°ln√≠)
                this.ctx.beginPath();
                this.ctx.moveTo(origin.x, 0);
                this.ctx.lineTo(origin.x, this.canvas.height);
                this.ctx.stroke();

                // Popisky os
                this.ctx.fillStyle = '#000';
                this.ctx.font = 'bold 22px Arial';

                // X na konci horizont√°ln√≠ osy vpravo
                this.ctx.textAlign = 'right';
                this.ctx.textBaseline = 'top';
                this.ctx.fillText('X', this.canvas.width - 10, origin.y + 5);

                // Z na vertik√°ln√≠ ose naho≈ôe
                this.ctx.textAlign = 'left';
                this.ctx.textBaseline = 'top';
                this.ctx.fillText('Z', origin.x + 5, 5);
            }

            drawPath(movements) {
                if (!movements || !Array.isArray(movements) || movements.length === 0) {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.drawAxes();
                    return;
                }

                const now = Date.now();
                if (now - this.lastUpdate < this.updateThreshold) return;
                this.lastUpdate = now;

                let batchRapid = [];
                let batchNormal = [];

                this.points = []; // Reset bod≈Ø

                for (let move of movements) {
                    const from = this.worldToScreen(move.fromX, move.fromZ);

                    // P≈ôidat poƒç√°teƒçn√≠ bod do detekce pro v≈°echny pohyby kromƒõ rychloposuvu
                    if (!move.rapid) {
                        this.points.push({
                            screenX: from.x,
                            screenY: from.y,
                            x: move.fromX,
                            z: move.fromZ,
                            isStart: true // Oznaƒçen√≠ poƒç√°teƒçn√≠ho bodu
                        });
                    }

                    if (move.isArc && move.arcPoints) {
                        // Vykreslit oblouk po jednotliv√Ωch bodech
                        this.ctx.beginPath();
                        this.ctx.moveTo(from.x, from.y);

                        for (let point of move.arcPoints) {
                            const screenPoint = this.worldToScreen(point.x, point.z);
                            this.ctx.lineTo(screenPoint.x, screenPoint.y);
                        }

                        this.ctx.strokeStyle = '#007bff';
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();

                        // Vykreslit st≈ôed oblouku
                        if (move.center) {
                            const center = this.worldToScreen(move.center.x, move.center.z);
                            this.ctx.strokeStyle = '#00ff00';
                            this.ctx.beginPath();
                            this.ctx.moveTo(center.x - 5, center.y - 5);
                            this.ctx.lineTo(center.x + 5, center.y + 5);
                            this.ctx.moveTo(center.x + 5, center.y - 5);
                            this.ctx.lineTo(center.x - 5, center.y + 5);
                            this.ctx.stroke();

                            // P≈ôidat st≈ôed do bod≈Ø pro tooltip
                            this.points.push({
                                screenX: center.x,
                                screenY: center.y,
                                x: move.center.x,
                                z: move.center.z,
                                isCenter: true
                            });
                        }

                        // P≈ôidat koncov√Ω bod do detekce
                        const to = this.worldToScreen(move.toX, move.toZ);
                        this.points.push({
                            screenX: to.x,
                            screenY: to.y,
                            x: move.toX,
                            z: move.toZ
                        });

                        // Vykreslit body jako mal√© krou≈æky
                        this.ctx.fillStyle = '#007bff';
                        this.ctx.beginPath();
                        this.ctx.arc(to.x, to.y, 3, 0, Math.PI * 2);
                        this.ctx.fill();
                    } else {
                        // P≈Øvodn√≠ vykreslen√≠ p≈ô√≠m√Ωch pohyb≈Ø
                        const to = this.worldToScreen(move.toX, move.toZ);
                        if (move.rapid) {
                            batchRapid.push({from, to});
                        } else {
                            batchNormal.push({from, to});
                        }

                        // P≈ôidat koncov√Ω bod do detekce
                        this.points.push({
                            screenX: to.x,
                            screenY: to.y,
                            x: move.toX,
                            z: move.toZ
                        });

                        // Vykreslit body
                        this.ctx.fillStyle = move.rapid ? '#ff0000' : '#007bff';
                        this.ctx.beginPath();
                        this.ctx.arc(to.x, to.y, 3, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }

                // Vykreslen√≠ rychloposuv≈Ø
                this.ctx.strokeStyle = '#ff0000';
                this.ctx.beginPath();
                this.ctx.lineWidth = 1;
                for (let move of batchRapid) {
                    this.ctx.moveTo(move.from.x, move.from.y);
                    this.ctx.lineTo(move.to.x, move.to.y);
                }
                this.ctx.stroke();

                // Vykreslen√≠ pracovn√≠ch posuv≈Ø
                this.ctx.strokeStyle = '#007bff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                for (let move of batchNormal) {
                    this.ctx.moveTo(move.from.x, move.from.y);
                    this.ctx.lineTo(move.to.x, move.to.y);
                }
                this.ctx.stroke();

                // Vykreslit st≈ôedy oblouk≈Ø
                this.ctx.strokeStyle = '#00ff00';
                this.ctx.fillStyle = '#00ff00';

                for (let move of movements) {
                    if (move.isArc && move.arcCenter) {
                        const center = this.worldToScreen(move.arcCenter.x, move.arcCenter.z);
                        // Vykreslen√≠ k≈ô√≠≈æku pro st≈ôed
                        this.ctx.beginPath();
                        this.ctx.moveTo(center.x - 5, center.y - 5);
                        this.ctx.lineTo(center.x + 5, center.y + 5);
                        this.ctx.moveTo(center.x + 5, center.y - 5);
                        this.ctx.lineTo(center.x - 5, center.y + 5);
                        this.ctx.stroke();

                        // P≈ôidat tooltip se sou≈ôadnicemi st≈ôedu
                        this.points.push({
                            screenX: center.x,
                            screenY: center.y,
                            x: move.arcCenter.x,
                            z: move.arcCenter.z,
                            isCenter: true
                        });
                    }
                }

                // Aktualizace pozice pouze pro posledn√≠ pohyb
                if (movements.length > 0) {
                    const lastMove = movements[movements.length - 1];
                    posXElement.textContent = lastMove.toX.toFixed(3);
                    posZElement.textContent = lastMove.toZ.toFixed(3);
                }

                this.lastMovements = movements;

                // P≈ôidat vykreslen√≠ zv√Ωraznƒõn√©ho bodu
                if (this.highlightedPoint) {
                    const point = this.worldToScreen(this.highlightedPoint.x, this.highlightedPoint.z);
                    this.ctx.save();
                    // Vykreslen√≠ pevn√©ho bodu
                    this.ctx.beginPath();
                    this.ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                    this.ctx.fillStyle = '#ff0000';
                    this.ctx.fill();
                    // Statick√° kru≈ænice pro lep≈°√≠ viditelnost
                    this.ctx.beginPath();
                    this.ctx.arc(point.x, point.y, 15, 0, Math.PI * 2);
                    this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                    // Pulzuj√≠c√≠ kru≈ænice
                    const now = Date.now();
                    const phase = (now % 1000) / 1000;
                    const radius = 8 + Math.sin(phase * Math.PI * 2) * 4; // 4-12px
                    this.ctx.beginPath();
                    this.ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
                    this.ctx.strokeStyle = '#ff0000';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();

                    this.ctx.restore();

                    // Po≈æ√°dat o dal≈°√≠ sn√≠mek animace
                    requestAnimationFrame(() => this.drawPath(movements));
                }
            }

            handleMouseMove(event) {
                if (this.isDragging) return; // Nedetekovat body bƒõhem posouv√°n√≠ pohledu
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                // Kontrola bl√≠zkosti bod≈Ø
                const hitPoint = this.points.find(point => {
                    const dx = mouseX - point.screenX;
                    const dy = mouseY - point.screenY;
                    return Math.sqrt(dx * dx + dy * dy) < 5;
                });

                if (hitPoint) {
                    this.canvas.style.cursor = 'pointer';
                    this.tooltip.style.display = 'block';
                    this.tooltip.style.left = (event.clientX + 10) + 'px';
                    this.tooltip.style.top = (event.clientY - 20) + 'px';
                    if (hitPoint.isCenter) {
                        this.tooltip.textContent = `St≈ôed: X${this.formatNumber(hitPoint.x)} Z${this.formatNumber(hitPoint.z)}`;
                    } else {
                        this.tooltip.textContent = `X${this.formatNumber(hitPoint.x)} Z${this.formatNumber(hitPoint.z)}`;
                    }
                } else {
                    this.canvas.style.cursor = this.isDragging ? 'grabbing' : 'default';
                    this.tooltip.style.display = 'none';
                }
            }

            calculateBounds(movements) {
                if (!movements || movements.length === 0) return null;
                let minX = Infinity;
                let maxX = -Infinity;
                let minZ = Infinity;
                let maxZ = -Infinity;

                movements.forEach(move => {
                    minX = Math.min(minX, move.fromX, move.toX);
                    maxX = Math.max(maxX, move.fromX, move.toX);
                    minZ = Math.min(minZ, move.fromZ, move.toZ);
                    maxZ = Math.max(maxZ, move.fromZ, move.toZ);
                });

                // P≈ôidat mal√Ω okraj pro pr√°zdn√© programy nebo jednotliv√© body
                if (minX === maxX) {
                    minX -= 5;
                    maxX += 5;
                }
                if (minZ === maxZ) {
                    minZ -= 5;
                    maxZ += 5;
                }

                return { minX, maxX, minZ, maxZ };
            }

            adjustScale(bounds) {
                if (!bounds) return;
                this.programBounds = bounds; // Ulo≈æit hranice programu

                const width = bounds.maxX - bounds.minX;
                const height = bounds.maxZ - bounds.minZ;

                // Vypoƒçet z√°kladn√≠ho mƒõ≈ô√≠tka pouze pokud nem√°me ulo≈æen√© hranice
                if (!this.baseScale || this.baseScale === 1) {
                    const scaleX = (this.canvas.width - this.padding * 2) / (width || 1);
                    const scaleY = (this.canvas.height - this.padding * 2) / (height || 1);
                    this.baseScale = Math.min(scaleX, scaleY);
                }
                this.scale = this.baseScale * this.zoomFactor;

                // Centrovat dr√°hy vzhledem k os√°m p≈ôi resetu
                if (!this.isDragging && !this.programBounds) {
                    const origin = this.worldToScreen(0, 0);
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    this.centerX += centerX - origin.x;
                    this.centerY += centerY - origin.y;
                }
            }

            resetView() {
                const program = editor.value;
                if (!program.trim()) return;

                this.parser.parseProgram(program).then(movements => {
                    if (movements && Array.isArray(movements)) {
                        // Filtrovat pouze pracovn√≠ pohyby (G1)
                        const workMoves = movements.filter(move => !move.rapid);

                        if (workMoves.length > 0) {
                            // Vypoƒç√≠tat hranice pouze pro pracovn√≠ pohyby
                            const bounds = {
                                minX: Math.min(...workMoves.map(m => Math.min(m.fromX, m.toX))),
                                maxX: Math.max(...workMoves.map(m => Math.max(m.fromX, m.toX))),
                                minZ: Math.min(...workMoves.map(m => Math.min(m.fromZ, m.toZ))),
                                maxZ: Math.max(...workMoves.map(m => Math.max(m.fromZ, m.toZ)))
                            };

                            // P≈ôidat okraj 10% pro lep≈°√≠ zobrazen√≠
                            const margin = {
                                x: (bounds.maxX - bounds.minX) * 0.1,
                                z: (bounds.maxZ - bounds.minZ) * 0.1
                            };

                            bounds.minX -= margin.x;
                            bounds.maxX += margin.x;
                            bounds.minZ -= margin.z;
                            bounds.maxZ += margin.z;

                            // Vypoƒç√≠tat mƒõ≈ô√≠tko pro p≈ôizp≈Øsoben√≠ pohledu
                            const width = bounds.maxZ - bounds.minZ;
                            const height = bounds.maxX - bounds.minX;

                            const scaleX = this.canvas.width / width;
                            const scaleY = this.canvas.height / height;

                            // Pou≈æ√≠t men≈°√≠ mƒõ≈ô√≠tko pro zachov√°n√≠ pomƒõru stran
                            this.baseScale = Math.min(scaleX, scaleY);
                            this.zoomFactor = 1;
                            this.scale = this.baseScale;

                            // Vypoƒç√≠tat st≈ôed pro centrov√°n√≠
                            const centerX = (bounds.minX + bounds.maxX) / 2;
                            const centerZ = (bounds.minZ + bounds.maxZ) / 2;

                            // Nastavit pozici pohledu
                            this.centerX = this.canvas.width / 2 - centerX * this.scale;
                            this.centerY = this.canvas.height / 2 + centerZ * this.scale;

                            // P≈ôekreslit
                            this.gridCache = this.createGridCache();
                            this.simulate(true);
                        } else {
                            // Pokud nejsou pracovn√≠ pohyby, zobrazit cel√Ω program
                            const bounds = this.calculateBounds(movements);
                            if (bounds) {
                                // ... p≈Øvodn√≠ k√≥d pro v≈°echny pohyby ...
                            }
                        }
                    }
                }).catch(error => {
                    console.error('Chyba p≈ôi parsov√°n√≠ programu:', error);
                });
            }

            worldToScreen(x, z) {
                return {
                    x: this.centerX + x * this.scale,     // X na horizont√°ln√≠ osu
                    y: this.centerY - z * this.scale      // Z na vertik√°ln√≠ osu - opraveno znam√©nko
                };
            }

            async simulate(resetView = false) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                const program = editor.value;

                if (program.trim()) {
                    debug('Spu≈°tƒõn√≠ simulace programu');
                    const movements = await this.parser.parseProgram(program);
                    const bounds = this.calculateBounds(movements);
                    // P≈ôizp≈Øsobit mƒõ≈ô√≠tko podle rozmƒõr≈Ø programu

                    if (resetView) {
                        this.lastSelectedPoint = null;
                        selectedPosXElement.textContent = '-';
                        selectedPosZElement.textContent = '-';
                    }

                    this.adjustScale(bounds);
                    this.drawAxes();
                    this.drawPath(movements);
                    debug('Simulace dokonƒçena');
                } else {
                    this.drawAxes();
                }
            }

            formatNumber(num) {
                // Zaokrouhlit na 3 desetinn√° m√≠sta a p≈ôev√©st na string
                const rounded = Number(num).toFixed(3);
                // Odstranit koncov√© nuly za desetinnou ƒç√°rkou a p≈ô√≠padnƒõ i desetinnou ƒç√°rku
                return rounded.replace(/\.?0+$/, '');
            }

            checkPointUnderCrosshair(x, y) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = x - rect.left;
                const mouseY = y - rect.top;

                const hitPoint = this.points.find(point => {
                    const dx = mouseX - point.screenX;
                    const dy = mouseY - point.screenY;
                    return Math.sqrt(dx * dx + dy * dy) < 15; // Vƒõt≈°√≠ tolerance pro dotyk
                });

                if (hitPoint) {
                    this.tooltip.style.display = 'block';
                    this.tooltip.style.left = (x + 20) + 'px';
                    this.tooltip.style.top = (y - 30) + 'px';
                    this.tooltip.textContent = `X${this.formatNumber(hitPoint.x)} Z${this.formatNumber(hitPoint.z)}`;

                    // Aktualizujeme posledn√≠ vybran√Ω bod a jeho sou≈ôadnice
                    this.lastSelectedPoint = hitPoint;
                    this.updateSelectedPosition(hitPoint.x, hitPoint.z);
                } else {
                    this.tooltip.style.display = 'none';
                }
            }

            updateSelectedPosition(x, z) {
                if (x !== null && z !== null) {
                    selectedPosXElement.textContent = this.formatNumber(x);
                    selectedPosZElement.textContent = this.formatNumber(z);
                }
            }

            highlightPoint(x, z) {
                // Hledat bod s toleranc√≠ kv≈Øli zaokrouhlovac√≠m chyb√°m
                this.highlightedPoint = this.points.find(point => {
                    const dx = Math.abs(point.x - x);
                    const dz = Math.abs(point.z - z);
                    return dx < 0.001 && dz < 0.001; // tolerance 0.001mm
                });

                // Pokud nen√≠ nalezen p≈ôesn√Ω bod, vytvo≈ô√≠me nov√Ω
                if (!this.highlightedPoint) {
                    this.highlightedPoint = { x, z };
                }

                // P≈ôidat animaƒçn√≠ smyƒçku pro plynulou animaci
                const animate = () => {
                    if (this.highlightedPoint) {
                        const point = this.worldToScreen(this.highlightedPoint.x, this.highlightedPoint.z);

                        this.ctx.save();

                        // Vykreslen√≠ pevn√©ho bodu
                        this.ctx.beginPath();
                        this.ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                        this.ctx.fillStyle = '#ff0000';
                        this.ctx.fill();

                        // Pulzuj√≠c√≠ kru≈ænice
                        const now = Date.now();
                        const phase = (now % 1000) / 1000;
                        const radius = 8 + Math.sin(phase * Math.PI * 2) * 4;

                        this.ctx.beginPath();
                        this.ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
                        this.ctx.strokeStyle = '#ff0000';
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();

                        this.ctx.restore();

                        // Pokraƒçovat v animaci
                        requestAnimationFrame(animate);
                    }
                };

                // Spustit animaƒçn√≠ smyƒçku
                animate();
            }

            clearHighlight() {
                this.highlightedPoint = null;
                // P≈ôidat kontrolu na existenci this.lastMovements
                if (this.lastMovements) {
                    this.drawPath(this.lastMovements);
                } else {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.drawAxes();
                }
            }

            handleCanvasClick(event) {
                if (this.isDragging) return;

                const rect = this.canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                // Vymazat p≈ôedchoz√≠ zv√Ωraznƒõn√≠
                this.clearHighlight();

                // Naj√≠t bod pod my≈°√≠ s vƒõt≈°√≠ toleranc√≠
                const hitPoint = this.points.find(point => {
                    const dx = mouseX - point.screenX;
                    const dy = mouseY - point.screenY;
                    return Math.sqrt(dx * dx + dy * dy) < 8; // Zvƒõt≈°en√° tolerance
                });

                if (hitPoint) {
                    const lineIndex = this.findLineByCoordinates(hitPoint.x, hitPoint.z);
                    if (lineIndex >= 0) {
                        this.highlightLineAndPoint(lineIndex, hitPoint);
                    }
                }
            }

            // P≈ôidat novou metodu pro zv√Ωraznƒõn√≠ ≈ô√°dku a bodu
            highlightLineAndPoint(lineIndex, point) {
                // Nejprve vyƒçistit p≈ôedchoz√≠ zv√Ωraznƒõn√≠
                this.clearHighlight();

                // Odstranit p≈ôedchoz√≠ ≈°ipky
                const lines = editor.value.split('\n').map(line => line.replace(/^‚Üí\s*/, ''));

                // P≈ôidat ≈°ipku k vybran√©mu ≈ô√°dku
                lines[lineIndex] = '‚Üí ' + lines[lineIndex];
                editor.value = lines.join('\n');

                // Aktualizovat zobrazen√© sou≈ôadnice
                selectedPosXElement.textContent = this.formatNumber(point.x);
                selectedPosZElement.textContent = this.formatNumber(point.z);

                // Zv√Ωraznit bod
                this.highlightPoint(point.x, point.z);

                // Scrollovat k vybran√©mu ≈ô√°dku
                const lineHeight = parseFloat(getComputedStyle(editor).lineHeight);
                editor.scrollTop = lineIndex * lineHeight;

                // P≈ôekreslit
                this.drawPath(this.lastMovements);
            }

            clearAllHighlights() {
                this.highlightedPoint = null;
                this.highlightedPoints = []; // P≈ôidat nov√© pole pro v√≠ce zv√Ωraznƒõn√Ωch bod≈Ø
                if (this.lastMovements) {
                    this.drawPath(this.lastMovements);
                } else {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.drawAxes();
                }
            }

            findLineByCoordinates(targetX, targetZ) {
                // Proj√≠t v≈°echny pohyby a naj√≠t ten, kter√Ω konƒç√≠ na dan√Ωch sou≈ôadnic√≠ch
                let movements = [];
                const program = editor.value;

                // Resetovat parser pro spr√°vn√© hodnoty
                this.parser.reset();

                const lines = program.split('\n');
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line || line.startsWith(';')) continue;

                    const coords = this.parser.parseCoordinates(line);
                    if (coords.hasCoordinates) {
                        if (Math.abs(coords.x - targetX) < 0.001 &&
                            Math.abs(coords.z - targetZ) < 0.001) {
                            return i; // Vr√°tit index ≈ô√°dku
                        }
                        // Aktualizovat pozici parseru
                        this.parser.currentX = coords.x;
                        this.parser.currentZ = coords.z;
                    }
                }
                return -1;
            }

            highlightLineAndPoint(lineIndex, point) {
                // Nejprve vyƒçistit p≈ôedchoz√≠ zv√Ωraznƒõn√≠
                this.clearHighlight();

                // Odstranit p≈ôedchoz√≠ ≈°ipky
                const lines = editor.value.split('\n');
                const cleanLines = lines.map(line => line.replace(/^‚Üí\s*/, ''));

                // P≈ôidat ≈°ipku k vybran√©mu ≈ô√°dku
                cleanLines[lineIndex] = '‚Üí ' + cleanLines[lineIndex];
                editor.value = cleanLines.join('\n');

                // Aktualizovat zobrazen√© sou≈ôadnice
                selectedPosXElement.textContent = this.formatNumber(point.x);
                selectedPosZElement.textContent = this.formatNumber(point.z);

                // Zv√Ωraznit bod
                this.highlightPoint(point.x, point.z);

                // Scrollovat k vybran√©mu ≈ô√°dku
                const lineHeight = parseFloat(getComputedStyle(editor).lineHeight);
                editor.scrollTop = lineIndex * lineHeight;

                // P≈ôekreslit
                this.drawPath(this.lastMovements);
            }

            async simulateToLine(lineIndex) {
                const program = editor.value;
                const lines = program.split('\n').slice(0, lineIndex + 1).join('\n');
                const movements = await this.parser.parseProgram(lines);
                this.drawPath(movements);
            }
        }

        class CNCPlayer {
            constructor(simulator) {
                this.simulator = simulator;
                this.movements = [];
                this.currentIndex = 0;
                this.isPlaying = false;
                this.playTimer = null;
                this.speed = 50; // V√Ωchoz√≠ rychlost (1-100)

                // Ovl√°dac√≠ prvky
                this.playBtn = document.getElementById('playBtn');
                this.prevBtn = document.getElementById('prevBtn');
                this.nextBtn = document.getElementById('nextBtn');
                this.speedSlider = document.getElementById('speedSlider');
                this.currentLineSpan = document.getElementById('currentLine');
                this.totalLinesSpan = document.getElementById('totalLines');

                // Event listeners
                this.playBtn.addEventListener('click', () => this.togglePlay());
                this.prevBtn.addEventListener('click', () => this.prev());
                this.nextBtn.addEventListener('click', () => this.next());
                this.speedSlider.addEventListener('input', (e) => this.setSpeed(e.target.value));

                this.updateControls();
            }

            togglePlay() {
                if (this.isPlaying) {
                    this.pause();
                } else {
                    this.play();
                }
            }

            play() {
                if (this.currentIndex >= this.movements.length) {
                    this.currentIndex = 0;
                }
                this.isPlaying = true;
                this.playBtn.textContent = '‚è∏Ô∏è';
                this.playBtn.title = 'Pozastavit';
                this.updateControls();
                this.playNext();
            }

            pause() {
                this.isPlaying = false;
                this.playBtn.textContent = '‚ñ∂Ô∏è';
                this.playBtn.title = 'P≈ôehr√°t';
                clearTimeout(this.playTimer);
                this.updateControls();
            }

            prev() {
                if (this.currentIndex > 0) {
                    this.currentIndex--;
                    this.drawMovements(this.currentIndex);
                    this.updateCurrentLine();
                    this.updateControls();
                }
            }

            next() {
                if (this.currentIndex < this.movements.length) {
                    this.currentIndex++;
                    this.drawMovements(this.currentIndex);
                    this.updateCurrentLine();
                    this.updateControls();
                }
            }

            updateControls() {
                // Aktualizace stavu tlaƒç√≠tek
                this.prevBtn.disabled = this.currentIndex <= 0 || this.isPlaying;
                this.nextBtn.disabled = this.currentIndex >= this.movements.length || this.isPlaying;
                this.speedSlider.disabled = !this.isPlaying;
            }

            async setProgram(program) {
                this.movements = await this.simulator.parser.parseProgram(program);
                this.currentIndex = 0;
                this.totalLinesSpan.textContent = this.movements.length;
                this.updateCurrentLine();
                this.stop();
            }

            drawMovements(upToIndex) {
                // Vyƒçistit canvas
                this.simulator.ctx.clearRect(0, 0, this.simulator.canvas.width, this.simulator.canvas.height);

                // Vykreslit osy a m≈ô√≠≈æku
                this.simulator.drawAxes();

                // P≈ôipravit v≈°echny pohyby a≈æ do aktu√°ln√≠ho indexu
                const currentMovements = this.movements.slice(0, upToIndex + 1);

                if (currentMovements.length > 0) {
                    // Vykreslit v≈°echny p≈ôedchoz√≠ dr√°hy
                    this.simulator.drawPath(currentMovements);

                    // Z√≠skat aktu√°ln√≠ pohyb pro zv√Ωraznƒõn√≠
                    const currentMove = currentMovements[currentMovements.length - 1];

                    // Aktualizovat zobrazen√© sou≈ôadnice
                    posXElement.textContent = this.simulator.formatNumber(currentMove.toX);
                    posZElement.textContent = this.simulator.formatNumber(currentMove.toZ);
                    selectedPosXElement.textContent = this.simulator.formatNumber(currentMove.toX);
                    selectedPosZElement.textContent = this.simulator.formatNumber(currentMove.toZ);

                    // Zv√Ωraznit aktu√°ln√≠ bod
                    this.simulator.highlightPoint(currentMove.toX, currentMove.toZ);
                }
            }

            playNext() {
                if (!this.isPlaying || this.currentIndex >= this.movements.length) {
                    this.stop();
                    return;
                }

                // Vykreslit aktu√°ln√≠ pohyb vƒçetnƒõ zv√Ωraznƒõn√≠
                requestAnimationFrame(() => {
                    this.drawMovements(this.currentIndex);
                    this.updateCurrentLine();
                });

                // Zv√Ω≈°it index a≈æ po vykreslen√≠
                this.currentIndex++;

                // Napl√°novat dal≈°√≠ pohyb
                const delay = this.calculateDelay();
                this.playTimer = setTimeout(() => this.playNext(), delay);
            }

            calculateDelay() {
                // P≈ôevod rychlosti (1-100) na ƒças (1000ms - 50ms)
                return 1000 - (this.speed * 9.5);
            }

            stop() {
                clearTimeout(this.playTimer);
                this.isPlaying = false;
                this.currentIndex = 0;
                this.playBtn.textContent = '‚ñ∂Ô∏è';
                this.playBtn.title = 'P≈ôehr√°t';
                this.updateCurrentLine();
                this.updateControls();
                this.simulator.simulate(); // P≈ôekreslit celou simulaci
            }

            step() {
                if (this.currentIndex < this.movements.length) {
                    this.drawMovements(this.currentIndex);
                    this.currentIndex++;
                    this.updateCurrentLine();
                }
            }

            setSpeed(value) {
                this.speed = parseInt(value);
                if (this.isPlaying) {
                    // Restartovat p≈ôehr√°v√°n√≠ s novou rychlost√≠
                    clearTimeout(this.playTimer);
                    this.playNext();
                }
            }

            updateCurrentLine() {
                this.currentLineSpan.textContent = this.currentIndex;
            }
        }

        // Event handlers
        window.addEventListener('DOMContentLoaded', () => {
            try {
                // Vytvo≈ôit glob√°ln√≠ simul√°tor
                window.simulator = new Simulator();

                // Nastavit cestu k adres√°≈ôi
                const currentPath = window.location.pathname;
                const baseDirectory = currentPath.substring(0, currentPath.lastIndexOf('/'));
                if (window.simulator && window.simulator.parser) {
                    window.simulator.parser.setBaseDirectory(baseDirectory);
                }

                // Vytvo≈ôit p≈ôehr√°vaƒç
                if (window.simulator) {
                    window.simulator.player = new CNCPlayer(window.simulator);
                }

                // Event listener pro v√Ωbƒõr soubor≈Ø
                const fileInput = document.getElementById('actualFileInput');
                const programList = document.getElementById('programList');

                if (fileInput && programList) {
                    fileInput.addEventListener('change', async function(event) {
                        if (!window.simulator || !window.simulator.parser) return;

                        const files = Array.from(this.files);
                        programList.innerHTML = '';

                        // Naƒç√≠st v≈°echny soubory
                        for (const file of files) {
                            await window.simulator.parser.loadProgram(file);

                            const item = document.createElement('div');
                            item.className = 'program-list-item';
                            const displayName = file.name.replace(/\.(SPF|MPF)$/i, '');
                            item.textContent = displayName;
                            item.onclick = async () => {
                                programList.querySelectorAll('.program-list-item')
                                    .forEach(i => i.classList.remove('active'));
                                item.classList.add('active');

                                const content = window.simulator.parser.getProgram(file.name);
                                if (content) {
                                    editor.value = content;
                                    await simulateProgram();
                                    window.simulator.resetView(); // P≈ôidat automatick√Ω reset pohledu
                                }
                            };
                            programList.appendChild(item);
                        }

                        // Automaticky naƒç√≠st prvn√≠ program
                        if (files.length > 0) {
                            const firstFile = files[0];
                            const content = await window.simulator.parser.loadProgram(firstFile);
                            if (content) {
                                editor.value = content;
                                programList.firstChild?.classList.add('active');
                                await simulateProgram();
                                window.simulator.resetView(); // P≈ôidat automatick√Ω reset pohledu
                            }
                        }

                        debug(`Naƒçteno ${files.length} program≈Ø`);
                    });
                }

                // Event listener pro editor
                const editor = document.getElementById('editor');
                if (editor) {
                    const debouncedSimulate = debounce(() => {
                        if (window.simulator) {
                            window.simulator.simulate();
                        }
                    }, 100);
                    editor.addEventListener('input', debouncedSimulate);
                }
            } catch (error) {
                console.error('Chyba p≈ôi inicializaci:', error);
            }
        });

        window.saveFile = function() {
            const content = editor.value;
            if (!content.trim()) {
                alert('Nelze ulo≈æit pr√°zdn√Ω program');
                return;
            }

            const blob = new Blob([content], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');

            a.href = url;
            a.download = 'program.mpf';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            window.URL.revokeObjectURL(url);
            debug('Program ulo≈æen');
        }

        window.resetView = function() {
            if (window.simulator) {
                window.simulator.resetView();
            }
        }

        // Upravit event listener pro kliknut√≠ na ≈ô√°dek v editoru
        editor.addEventListener('click', async function(e) {
            const cursorPosition = editor.selectionStart;
            const lines = editor.value.split('\n');
            if (!lines.length) return;

            const clickedLineIndex = editor.value.substr(0, cursorPosition).split('\n').length - 1;
            if (clickedLineIndex < 0) return;

            const line = lines[clickedLineIndex];
            if (!line) return;

            // Nejprve vyƒçistit v≈°echna p≈ôedchoz√≠ zv√Ωraznƒõn√≠
            window.simulator.clearAllHighlights();

            // Pou≈æ√≠t novou metodu parseCoordinates
            const coords = window.simulator.parser.parseCoordinates(line);
            if (coords.hasCoordinates) {
                window.simulator.highlightLineAndPoint(clickedLineIndex, {
                    x: coords.x,
                    z: coords.z
                });

                // P≈ôehr√°t pohyby a≈æ po vybran√Ω bod
                if (window.simulator.player) {
                    // Naj√≠t index pohybu odpov√≠daj√≠c√≠ vybran√©mu ≈ô√°dku
                    const movements = await window.simulator.parser.parseProgram(editor.value);
                    const targetPoint = { x: coords.x, z: coords.z };

                    // Naj√≠t index posledn√≠ho pohybu p≈ôed nebo na vybran√©m ≈ô√°dku
                    let moveIndex = movements.findIndex(move =>
                        Math.abs(move.toX - targetPoint.x) < 0.001 &&
                        Math.abs(move.toZ - targetPoint.z) < 0.001
                    );

                    if (moveIndex >= 0) {
                        // Nastavit index v p≈ôehr√°vaƒçi
                        window.simulator.player.currentIndex = moveIndex + 1;
                        // Vykreslit v≈°echny pohyby a≈æ po tento index
                        window.simulator.player.drawMovements(moveIndex);
                        // Aktualizovat poƒç√≠tadlo ≈ô√°dk≈Ø
                        window.simulator.player.updateCurrentLine();
                    }
                }

                // Zobrazit celou simulaci do oznaƒçen√©ho bodu
                await window.simulator.simulateToLine(clickedLineIndex);
            }
        });

        // P≈ôidat event listener pro opakovan√© p≈ôekreslen√≠ p≈ôi zmƒõnƒõ velikosti okna
        window.addEventListener('resize', debounce(() => {
            if (window.simulator) {
                window.simulator.setupCanvas();
                window.simulator.simulate();
            }
        }, 250));

        // P≈ôidat mo≈ænost v√Ωbƒõru slo≈æky s podprogramy
        window.selectProgramDirectory = function() {
            if (!window.simulator || !window.simulator.parser) {
                console.error('Simul√°tor nen√≠ inicializov√°n');
                return;
            }

            const input = document.createElement('input');
            input.type = 'file';
            input.webkitdirectory = true;
            input.multiple = true;

            input.addEventListener('change', async function(e) {
                if (this.files.length > 0) {
                    await window.simulator.parser.loadSubprogramDirectory(this.files);
                    debug(`Naƒçteno ${this.files.length} podprogram≈Ø`);
                }
            });

            input.click();
        }

        // P≈ôidat glob√°ln√≠ funkci simulateProgram
        window.simulateProgram = async function() {
            if (window.simulator) {
                await window.simulator.simulate();
                if (window.simulator.player) {
                    await window.simulator.player.setProgram(editor.value);
                }
            }
        }

        // P≈ôidat funkce pro pr√°ci s mod√°ln√≠m oknem
        function showParameters() {
            const modal = document.getElementById('parametersModal');
            const tableBody = document.getElementById('parametersTableBody');
            tableBody.innerHTML = '';

            // Z√≠skat se≈ôazen√© parametry, pouze nenulov√© nebo explicitnƒõ definovan√©
            const parameters = Array.from(window.simulator.parser.parameters.entries())
                .filter(([_, value]) => value !== 0) // Filtrovat pouze nenulov√© hodnoty
                .sort((a, b) => {
                    const numA = parseInt(a[0].replace('R', ''));
                    const numB = parseInt(b[0].replace('R', '')); // Opraveno - odstranƒõn p≈ôebyteƒçn√Ω uz√°vorkuj√≠c√≠ oper√°tor
                    return numA - numB;
                });

            if (parameters.length === 0) {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td colspan="2" style="text-align: center; padding: 20px;">
                        ≈Ω√°dn√© definovan√© parametry
                    </td>
                `;
                tableBody.appendChild(row);
            } else {
                // Naplnit tabulku parametry
                for (const [param, value] of parameters) {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${param}</td>
                        <td>${typeof value === 'number' ? value.toFixed(3) : value}</td>
                    `;
                    tableBody.appendChild(row);
                }
            }

            modal.style.display = 'block';
        }

        function closeParametersModal() {
            const modal = document.getElementById('parametersModal');
            modal.style.display = 'none';
        }

        // P≈ôidat event listener pro zav≈ôen√≠ mod√°lu kliknut√≠m mimo nƒõj
        window.onclick = function(event) {
            const modal = document.getElementById('parametersModal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        }
    </script>
</body>
</html>
